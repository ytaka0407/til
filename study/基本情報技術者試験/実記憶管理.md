<h1>実記憶管理</h1>
主記憶にプログラムをロードする際の主記憶上でのプログラムの設置方法。<br>
主記憶の記憶領域を効率よく行うための仕組み。大きさに関わらず、区画一つにつき一つのプログラムをロードする。<br>
<h2>固定区画方式</h2>
主記憶全体が決まった大きさ区画で固定されている。区画が単一か複数かで方式が変わる。<br>
<h3>単一区画方式</h3>
全体が一つの区画になっている。区画一つなので一つのプログラムしかロードできない。<br>
つまりマルチプログラミングができない。
<h3>多重区画方式</h3>
全体が複数区画に分かれている。区画の大きさがそれぞれ異なることもある。<br>
最大で区画の数だけロードできるし区画が動的ではないので管理は楽だが<br>
4GB、8GB、16GBで区画が分かれている場合、17GB以上のプログラムはロードできない。<br>
また、16GBのところに10GBのプログラムをロードして区画内に6GB余っても使うことができない。
<h2>可変区画方式</h2>
ロードするプログラムで区画が変わる。<br>
<h3>メリット</h3>
・区画に無駄がないので効率が上がる。<br>
・未使用領域をひとつの領域として使えるので、大きなプログラムのロードも行いやすい<br>
<h3>デメリット</h3>
・フラグメンテーション<br>
プログラムのロードを繰り返すにつれフラグメンテーションか起こる<br>
最初にプログラムを容量いっぱいにロードしたあと<br>
先に終わったプログラムが抜けていくとその跡地が細切れの空き領域になってしまう。
→対処法。<br>
メモリコンパクションもしくはガーベジコレクション(再配置処理)をかける。<br>
その時ロードされてるプログラムを整理して、空き領域を一つの連続した領域に直す<br>
部屋の中でばらばらになってる物を端に全部寄せて場所を開ける感じ。<br>
<h2>オーバーレイ方式(主記憶の容量を超えた大きさのプログラムをロードしたい時)</h2>
ロードしきれないサイズのプログラムを、刻んでセグメント単位にして、使うセグメントのみを都度ロードする。<br>
<h2>スワッピング方式(プログラムをロードする場所がない時)</h2>
マルチプログラミング環境内で優先度が高いプログラムを割り込ませる時<br>
ロードできる場所がない場合に行われるロード方法。<br>
一度優先度が低いプログラムを補助記憶装置に退避させて場所を開けて(スワップアウト)<br>
優先プログラムをロード実行<br>
そのあと補助記憶装置に退避したプログラムを再ロードする(スワップアウト)<br>
スワップアウトとスワップインを併せてスワッピング。<br>
低速な補助記憶装置へのアクセスが発生するので処理速度が遅くなる。

