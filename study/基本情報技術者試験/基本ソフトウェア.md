<h1>ソフトウェアの分類</h1>
<h2>システムソフトウェアは基本ソフトウェアとミドルウェアの2種</h2>
<h3>基本ソフトウェア</h3>
OS、言語プロセッサなど。<br>
コンピュータを動かすための土台
<h4>制御プログラム(カーネル)</h4>
OSのメインどころ。
応用ソフトウェアやミドルウェアを制御する。<br>
マイクロカーネル→機能を限定したカーネル
モノリシックカーネル→多数の機能を網羅
<h4>言語処理プログラム(言語プロセッサ)</h4>
プログラム→機械語(アセンブラ？)に読み替えるプログラム
<h4>サービスプログラム(ユーティリティ)</h4>
補助的なプログラム。ファイル圧縮プログラムなどが該当。
<h4>GUI(Graphical User Interface)</h4>
人がコンピューターを視覚的に操作するためのインターフェース。アイコンをポインティングデバイスでダブルクリック、など。<br>
人間の操作画面とCPU間のインターフェース
<h4>API(Application Program Interface)</h4>
アプリケーションとCPUとのインターフェース。間にOSのAPIを挟むことで、アプリケーションはすべてOSに対しての命令で統一することができる。<br>
メリットは<br>
開発効率アップ(開発時、APIを呼び出すだけでよいのでアプリケーション作成が楽になる。)<br>
操作性の統一(異なるアプリでの同じ命令の基本操作が同じなので操作性が上がる。)<br>
互換性の確保(OSが同じならハードを選ばず動く。)
<h4>ジョブ管理</h4>
利用者からみて一連のまとまった指示について、一つの単位としてジョブとしてまとめてカーネルが制御する。<br>
複数の命令をまとめたバッチファイル1つを一つのジョブと見なして効率よく実行するのと似ている。<br>
<h5>ジョブ管理の流れ</h5>
マスタスケジューラという管理プログラムがあるので、利用者はマスタスケジューラに対してジョブの実行を依頼。<br>
↓<br>
依頼を受け取ったマスタスケジューラが、ジョブスケジューラに依頼。自分は実行状況を監視して必要があれば利用者にフィードバック。<br>
↓<br>
ジョブスケジューラ<br>
リーダ(ジョブ待ち行列に登録)<br>
イニシエータ(優先度の高いジョブをジョブステップごとに細分化し、タスク管理に対して依頼)<br>
タスク管理にてジョブステップ実行<br>
ターミネータ(実行が終わったジョブを、出力待ちとして登録。実行のために使っていた記憶装置などのハードウェア資源を開放。)<br>
ターミネータ(実行が終わったジョブを、出力待ちとして登録。実行のために使っていた記憶装置などのハードウェア資源を開放。)<br>
ライタ(優先度の高いジョブから順に結果を出力)<br>
<h4>スプーリング</h4>
CPU(高速)と入出力装置(低速)との処理速度の差異を解決して効率を上げる手段。<br>
具体的には<br>
低速な装置とやり取りする際、高速な磁気ディスクを介して行い、処理効率を高める。<br>
上の行列ジョブスケジューラの待ち行列の行列を作る場所に当たる。処理はできなくてもスプール(貯めて)おくのは高速なので処理が止まらない。<br>
これにより、CPU側は入出力を待たずに磁気ディスクに処理結果を積み上げていけばいいので効率が上がる。<br>
併せて、入出力装置も1回ずつ処理結果が渡されるのを待たずにスプールされたデータをどんどん処理すればいいので早い。<br>
この時の装置ごとの単位時間あたりに処理できる仕事量をスループットと呼ぶ。<br>
<h4>タスク管理</h4>
ジョブがジョブステップに分解されタスク管理に渡されると、タスクが生成される。<br>
タスク=CPUでの仕事の単位。<br>
タスクの状態は３パターンあり、CPUの使用権待ちの順番や優先度などに応じて状態遷移する。<br>
①実行可能状態(実行待ち)<br>
②実行状態(CPU使用して実行中)<br>
③待機状態(実行中に発生した入出力処理が発生したため、処理終了を待機中)<br>
【重要】待機状態→実行状態に切り替わることはできず、必ず実行可能状態を挟む必要がある。<br>
また、状況によっては実行状態中にほかのタスクにCPUを明け渡すために終わってなくとも実行状態→実行可能状態になることもある。<br>
実効可能状態⇔実行状態の采配をするのがディスパッチャ<br>
ディスパッチャのタスクの割り振りの方式のことをタスクスケジューリングという。<br>
<h4>タスクスケジューリングの種類</h4>
<h5>到着順方式</h5>
実効可能状態になった順。タスクの内容によっての優先順位の概念がなく、実行途中でCPU使用権が奪われることがない。(ノンプリエンプション)<br>
<h5>優先順(プライオリティ)</h5>
タスクに優先度を設定し、優先度順に実行していく。<br>
実行中のタスクより高い優先度のものが後から実行可能状態に登場すると、実行途中でCPU使用権は後から来た優先度の高いものに移る。(プリエんぷしょん)<br>
<h5>ラウンドロビン方式</h5>
CPU使用権を一定時間ごとに切り替える。<br>
一定時間を超えると、タスク実行中でも使用権が移る。実行中タスクは実行待ちの最後に回る。<br>
<h4>マルチプログラミング</h4>
CPUの有効活用、遊んでいる時間がないように複数のタスクを並行して実行し、CPUのアイドル時間(遊休時間)をなくす。<br>
タスクAの実行中に入出力処理に入った裏で、タスクBのCPU処理をさせる。といった動き<br>
<h4>割込み処理</h4>

<h2>応用ソフトウェア</h2>


各種アプリケーション
