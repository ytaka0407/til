<h1>ソフトウェアの分類</h1>
<h2>システムソフトウェアは基本ソフトウェアとミドルウェアの2種</h2>
<h3>基本ソフトウェア</h3>
OS、言語プロセッサなど。<br>
コンピュータを動かすための土台
<h4>制御プログラム(カーネル)</h4>
OSのメインどころ。
応用ソフトウェアやミドルウェアを制御する。<br>
マイクロカーネル→機能を限定したカーネル
モノリシックカーネル→多数の機能を網羅
<h4>言語処理プログラム(言語プロセッサ)</h4>
プログラム→機械語(アセンブラ？)に読み替えるプログラム
<h4>サービスプログラム(ユーティリティ)</h4>
補助的なプログラム。ファイル圧縮プログラムなどが該当。
<h4>GUI(Graphical User Interface)</h4>
人がコンピューターを視覚的に操作するためのインターフェース。アイコンをポインティングデバイスでダブルクリック、など。<br>
人間の操作画面とCPU間のインターフェース
<h4>API(Application Program Interface)</h4>
アプリケーションとCPUとのインターフェース。間にOSのAPIを挟むことで、アプリケーションはすべてOSに対しての命令で統一することができる。<br>
メリットは<br>
開発効率アップ(開発時、APIを呼び出すだけでよいのでアプリケーション作成が楽になる。)<br>
操作性の統一(異なるアプリでの同じ命令の基本操作が同じなので操作性が上がる。)<br>
互換性の確保(OSが同じならハードを選ばず動く。)
<h4>ジョブ管理</h4>
利用者からみて一連のまとまった指示について、一つの単位としてジョブとしてまとめてカーネルが制御する。<br>
複数の命令をまとめたバッチファイル1つを一つのジョブと見なして効率よく実行するのと似ている。<br>
<h5>ジョブ管理の流れ</h5>
マスタスケジューラという管理プログラムがあるので、利用者はマスタスケジューラに対してジョブの実行を依頼。<br>
↓<br>
依頼を受け取ったマスタスケジューラが、ジョブスケジューラに依頼。自分は実行状況を監視して必要があれば利用者にフィードバック。<br>
↓<br>
ジョブスケジューラ<br>
リーダ(ジョブ待ち行列に登録)<br>
イニシエータ(優先度の高いジョブをジョブステップごとに細分化し、タスク管理に対して依頼)<br>
タスク管理にてジョブステップ実行<br>
ターミネータ(実行が終わったジョブを、出力待ちとして登録。実行のために使っていた記憶装置などのハードウェア資源を開放。)<br>
ライタ(優先度の高いジョブから順に結果を出力)<br>
<h2>応用ソフトウェア</h2>


各種アプリケーション
