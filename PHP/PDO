参考サイト
https://qiita.com/7968/items/6f089fec8dde676abb5b#%E7%AC%AC2%E7%AB%A0-%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86%E3%81%AE%E5%9F%BA%E7%A4%8E

データベースへの接続処理。最初の解釈が色々間違ってたので修正。
trycatchやってることざっくり
①Try{$db=new PDO(データベース情報)}
↓
Try{オブジェクト変数$dbに  new PDO(詳しい場所とかユーザー名とか)でデータベース接続処理のクラス(PDO)をインスタンス化して代入}
②catch(PDOException $e){echo 'DB接続エラー：' .$e->getMessage();}
catch(エラークラス　インスタンスを入れる変数){
任意の文字列と、エラークラスのインスタンス($eに入ってる)からエラークラスのメソッドgetMessage()を呼び出し
}
★エラーにならなければ、$dbはPDOインスタンスが入っておしまい。ここから先は$db(PDOインスタンス)からメソッド呼び出してデータベースを操作していく(この辺曖昧)
★エラーになったときの処理
catch(PDOException　変数$e){echo　'DB接続エラー：'　.　$e->getmessage();}
①(PDOException　変数$e)について
PDOException：PDOのエラークラス(クラス＝処理の塊的なの)。ExceptionというクラスははじめからPHPで設定されているクラス　
変数$e：インスタンス(クラス処理設計を処理として呼び出せるように変換したもの)を入れる変数
TryでPDOオブジェクトがうまく行かなかった場合にcatchに進んで、PDOExcepcionクラスのインスタンスを、変数$eに代入する処理。
②$e->getmessage()について
ｰ>アロー演算子とは、インスタンスを代入した変数名()ｰ>インスタンス化したクラスから呼び出せる処理(メソッド)を引っ張り出す演算子
①PDOExceptionクラスのインスタンスを代入した$eを使って、クラスPDOException 中のメソッドの一つであるgetmessageを呼び出す。
そもそもgetmessage()とは
「投げられた例外メッセージを返す」のが本質。
本来はtry{}catch{}の構文のtryの中で、そもそも例外時の処理としてExceptionクラスのインスタンスをcatchに投げるthrow  new Exception(例外時の処理)を書かなければいけない。
PDOクラスが特殊で、PDOクラスがエラーになった場合、書かなくても勝手にPDOException(のインスタンス)を投げてくれる。
散々調べて、クラスとインスタンスとtrycatchがやっとわかってきた。 （編集済み） 

takashima-日曜午前  23:17
クラス・インスタンス・オブジェクト指向について
友人のjavaSEと話してて聞いた話とか教えてもらった話。かなりイメージが湧いたのでメモ。
クラス→設計図。複数の処理の塊。インスタンス化しないと使えない。
・そもそもクラスに分ける理由→分業のしやすさ。インスタンス化する＝クラスが特定できる＝管理しやすい。
・開発現場だと、クラスごとにファイルを分けて分業することが多い。
めっっっちゃ教えてもらったのに３行になってしまった。。
いや多分もっと深いんだろうけど、今の私のレベルではここまでのアウトプットが精一杯です。。

php公式より
PDO::exec — SQL ステートメントを実行し、作用した行数を返す。
→変数に$conutに代入することで右辺のSQL文で何行いじったのかを出力できる。

$records=$db->query('SELECT * FROM my_items');
while($record=$records->fetch()){
    print($record['item_name']."\n");
}
全体でやってること
$db(=PDOクラス)のqueryメソッドを使ってSELECT　SQLを実行。
実行結果をPDOStatementクラスのfetchメソッドで1行目から順に取得して出力する。
それにしてもなんでいきなりwhile文に組み込んで複雑なの出してくるのかね。。
★PDO::queryメソッド　PHP公式より
SQL ステートメントを実行し、結果セットを PDOStatement オブジェクトとして返す。
★PDOStatementとは
queryメソッドを実行した時に返ってくるクラス。カラムの中身の情報を直接取得したりするメソッドが含まれているみたい。多分もっと複雑。
上記の例文だと
$records=$db->query('SELECT * FROM my_items')
で、$recordsからPDOStatementメソッドを呼び出せるようになる。
★fetch
上記のPDOStatementクラスメソッドの一つ
結果セットから次の行を取得する(php公式)
カラムの名前をキーとして連想配列で指定の行を変数に格納する。
公式
$records(格納先の変数)=$records(PDOStatementオブジェクト？この場合も＝インスタンスでいいのか？が入った変数)ｰ>fetch(呼び出したい行を指す整数)
で、今回の例文だと
fetch()の()を空欄にして、whileでループ。
1行目から順番に結果がfalseになる(返すデータ(行)がなくなる)まで順番に変数$recordに一行ずつ入れていく。
ループの処理として、入れたあとにprint($record[’item_name’]);でキーitem_nameで入れた行のitem_nameを取り出して出力する。
クラス・インスタンス・メソッドがある程度わかったらどの単語をどう調べればいいのかがわかってきた。
php公式詳しいしとても勉強になるー。

★prepareメソッド→bindParamもしくはbindValue→executeメソッドの流れまとめ
①prepareメソッド
PHPstatementクラスのexecuteメソッドを実行するための準備的なメソッド(詳しいところはとばす)。
ユーザー入力情報(＝パラメータ)のセキュリティを確保しながらデータベースへ接続準備を行うためのメソッド。
書き方
->prepare('SQL文')
SQL文のパラメータ部分を”?”もしくは”:(コロン)+変数”にして記述する。？もしくは:変数で場所をこの後値を入れる場所を確保するイメージ。
ちなみにこの確保された場所そのもののことをプレースホルダ、プレースホルダに仮置きした"？”や”:変数”のことをパラメータマーカーという。
返すのは文オブジェクト。
※PDOstatementオブジェクト？インスタンス？が生成され、メソッドが使えるようになる。
↓
↓
↓
②PDO statementのbindParamメソッドもしくはbindValueメソッド
書き方
->bindoParamもしくはbindValue(パラメータID, 　バインドしたいパラメータが入った変数,　必要ならパラメータに対してデータ型を指定。指定なしだと文字列指定)
これを実行することで、この後にexecuteメソッドが（prepareに入れてあった）SQL文を実施する時にSQL文のプレースホルダ部分にパラメータがバインドされる。
※パラメータID→疑問符パラメータの場合は位置を整数で指定（？が1個しかなかったら１,バインドしたい値。２個あったら２行書いてそれぞれ１、２と指定）・:変数パラメータの場合は:変数そのままIDとして指定。
※バインドしたいパラメータが入った変数→入力フォームのデータなら、フォームから取得したデータなので$POST_[]の配列の要素が入る。
※一回のbind系メソッドでバインドできるのはプレースホルダ一箇所のみ？？多分。
↓
↓
↓
③PDO statementのexecuteメソッドで①prepareメソッドで指定していたSQL(プリペアドステートメント)実行。
excuteメソッド詳細。公式サイト引用
(bindあり)
パラメータマーカに PHP 変数や値を(それぞれ)バインドするため PDOStatement::bindParam() や PDOStatement::bindValue() をコールする。 関連づけされたパラメータマーカがあれば、バインドされた変数は入力値を渡す もしくは出力値を受け取ります。
■書き方
変数=excute()のみ。色々指定しなくてよし。
→bind系メソッドの機能に「準備された SQL ステートメント中で、 対応する名前もしくは疑問符プレースホルダにパラメータをバインドします。」が含まれているからprepare(’SQL文’)+bind系メソッドが実行された時点で、ぜーんぶ準備が終わってて、excuteは実行ボタンみたいなもんらしい。
(bindなし)
あるいは、入力専用のパラメータ値の配列を渡す。この場合、全ての値は自動で文字列(PARAM_STR)として扱われる。
■書き方
変数=excute(array(　　))
array()の部分が入力専用の配列らしい。意味あんまりわかってないけど出力ができないのよねきっと。。
プレースホルダの形式で若干書き方が変わる。
★疑問符プレースホルダの場合
array(パラメータ1,パラメータ2)　？の登場順に合わせてパラメータを記載。
★:変数で指定した場合
array（パラメータID=>パラメータ1,パラメータID2=>パラメータ2)のように記載。
公式の例5はわけわかんなかったので飛ばすことにした。。
★（補足的に）bindParamとbindValueの違い(わかったところだけ)
bindParam→バインドするのはパラメータの入った変数。イメージは変数が指している先の中身。
executeメソッドが実行されて初めて中身が評価(多分確定される的な意味)される。
要はbindParam実行してからexecuteされるまでの間にに変数の中身が変わったら変わった後の値がバインドされる。
bindvalue→バインドするのはパラメータの入った変数の中身。イメージは変数の中の中身を直接見に行っている。
中身を直接見てるので、bindvalue実行とexcute実行の間に変数の中身が変わってもバインドされる内容は変わらない。
多分ここが一番の違いっぽい。

オブジェクトとインスタンスの違いがよくわからん。
メソッド→クラスごとに使える関数たち。
クラス→かたまり。多分抽象的な感じ。指すにしても概念的な。
クラス→インスタンス化(実体化)するとメソッド使えるようになる。
まではわかった。
テキストで、メソッド実行すると〇〇オブジェクトが生成されます。さて次はこの〇〇オブジェクトの☆☆メソッドを使います。
の時に、◯◯インスタンスとは言わないんだよなー。
他の方のzpの会話見る限り、オブジェクトも「実体化した物」を抽象的に指す感じなのかな。
あと、クラスから実体化したもののなかでインスタンスに該当するものしないものの差もわからん。
つまりはよくわからん。
